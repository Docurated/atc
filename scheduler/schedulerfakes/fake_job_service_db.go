// This file was generated by counterfeiter
package schedulerfakes

import (
	"sync"

	"github.com/concourse/atc/config"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/scheduler"
)

type FakeJobServiceDB struct {
	GetJobStub        func(job string) (db.SavedJob, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		job string
	}
	getJobReturns struct {
		result1 db.SavedJob
		result2 error
	}
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	UpdateBuildPreparationStub        func(prep db.BuildPreparation) error
	updateBuildPreparationMutex       sync.RWMutex
	updateBuildPreparationArgsForCall []struct {
		prep db.BuildPreparation
	}
	updateBuildPreparationReturns struct {
		result1 error
	}
	IsPausedStub        func() (bool, error)
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct{}
	isPausedReturns     struct {
		result1 bool
		result2 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	GetNextInputVersionsStub        func(versions *algorithm.VersionsDB, job string, inputs []config.JobInput) ([]db.BuildInput, bool, db.MissingInputReasons, error)
	getNextInputVersionsMutex       sync.RWMutex
	getNextInputVersionsArgsForCall []struct {
		versions *algorithm.VersionsDB
		job      string
		inputs   []config.JobInput
	}
	getNextInputVersionsReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 db.MissingInputReasons
		result4 error
	}
	GetMissingInputReasonsStub        func(algorithmInputConfigs algorithm.InputConfigs, inputs []config.JobInput, idealMapping algorithm.InputMapping) (db.MissingInputReasons, error)
	getMissingInputReasonsMutex       sync.RWMutex
	getMissingInputReasonsArgsForCall []struct {
		algorithmInputConfigs algorithm.InputConfigs
		inputs                []config.JobInput
		idealMapping          algorithm.InputMapping
	}
	getMissingInputReasonsReturns struct {
		result1 db.MissingInputReasons
		result2 error
	}
	GetBuildPreparationStub        func(int) (db.BuildPreparation, bool, error)
	getBuildPreparationMutex       sync.RWMutex
	getBuildPreparationArgsForCall []struct {
		arg1 int
	}
	getBuildPreparationReturns struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}
	GetIdealBuildInputsStub        func(jobName string) ([]db.BuildInput, error)
	getIdealBuildInputsMutex       sync.RWMutex
	getIdealBuildInputsArgsForCall []struct {
		jobName string
	}
	getIdealBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 error
	}
	GetCompromiseBuildInputsStub        func(jobName string) ([]db.BuildInput, error)
	getCompromiseBuildInputsMutex       sync.RWMutex
	getCompromiseBuildInputsArgsForCall []struct {
		jobName string
	}
	getCompromiseBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 error
	}
	UseInputsForBuildStub        func(buildID int, inputs []db.BuildInput) error
	useInputsForBuildMutex       sync.RWMutex
	useInputsForBuildArgsForCall []struct {
		buildID int
		inputs  []db.BuildInput
	}
	useInputsForBuildReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJobServiceDB) GetJob(job string) (db.SavedJob, error) {
	fake.getJobMutex.Lock()
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJob", []interface{}{job})
	fake.getJobMutex.Unlock()
	if fake.GetJobStub != nil {
		return fake.GetJobStub(job)
	} else {
		return fake.getJobReturns.result1, fake.getJobReturns.result2
	}
}

func (fake *FakeJobServiceDB) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeJobServiceDB) GetJobArgsForCall(i int) string {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return fake.getJobArgsForCall[i].job
}

func (fake *FakeJobServiceDB) GetJobReturns(result1 db.SavedJob, result2 error) {
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 db.SavedJob
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
	}
}

func (fake *FakeJobServiceDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakeJobServiceDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeJobServiceDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
	}
}

func (fake *FakeJobServiceDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakeJobServiceDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeJobServiceDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobServiceDB) UpdateBuildPreparation(prep db.BuildPreparation) error {
	fake.updateBuildPreparationMutex.Lock()
	fake.updateBuildPreparationArgsForCall = append(fake.updateBuildPreparationArgsForCall, struct {
		prep db.BuildPreparation
	}{prep})
	fake.recordInvocation("UpdateBuildPreparation", []interface{}{prep})
	fake.updateBuildPreparationMutex.Unlock()
	if fake.UpdateBuildPreparationStub != nil {
		return fake.UpdateBuildPreparationStub(prep)
	} else {
		return fake.updateBuildPreparationReturns.result1
	}
}

func (fake *FakeJobServiceDB) UpdateBuildPreparationCallCount() int {
	fake.updateBuildPreparationMutex.RLock()
	defer fake.updateBuildPreparationMutex.RUnlock()
	return len(fake.updateBuildPreparationArgsForCall)
}

func (fake *FakeJobServiceDB) UpdateBuildPreparationArgsForCall(i int) db.BuildPreparation {
	fake.updateBuildPreparationMutex.RLock()
	defer fake.updateBuildPreparationMutex.RUnlock()
	return fake.updateBuildPreparationArgsForCall[i].prep
}

func (fake *FakeJobServiceDB) UpdateBuildPreparationReturns(result1 error) {
	fake.UpdateBuildPreparationStub = nil
	fake.updateBuildPreparationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobServiceDB) IsPaused() (bool, error) {
	fake.isPausedMutex.Lock()
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct{}{})
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if fake.IsPausedStub != nil {
		return fake.IsPausedStub()
	} else {
		return fake.isPausedReturns.result1, fake.isPausedReturns.result2
	}
}

func (fake *FakeJobServiceDB) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *FakeJobServiceDB) IsPausedReturns(result1 bool, result2 error) {
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	} else {
		return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
	}
}

func (fake *FakeJobServiceDB) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakeJobServiceDB) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) GetNextInputVersions(versions *algorithm.VersionsDB, job string, inputs []config.JobInput) ([]db.BuildInput, bool, db.MissingInputReasons, error) {
	var inputsCopy []config.JobInput
	if inputs != nil {
		inputsCopy = make([]config.JobInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.getNextInputVersionsMutex.Lock()
	fake.getNextInputVersionsArgsForCall = append(fake.getNextInputVersionsArgsForCall, struct {
		versions *algorithm.VersionsDB
		job      string
		inputs   []config.JobInput
	}{versions, job, inputsCopy})
	fake.recordInvocation("GetNextInputVersions", []interface{}{versions, job, inputsCopy})
	fake.getNextInputVersionsMutex.Unlock()
	if fake.GetNextInputVersionsStub != nil {
		return fake.GetNextInputVersionsStub(versions, job, inputs)
	} else {
		return fake.getNextInputVersionsReturns.result1, fake.getNextInputVersionsReturns.result2, fake.getNextInputVersionsReturns.result3, fake.getNextInputVersionsReturns.result4
	}
}

func (fake *FakeJobServiceDB) GetNextInputVersionsCallCount() int {
	fake.getNextInputVersionsMutex.RLock()
	defer fake.getNextInputVersionsMutex.RUnlock()
	return len(fake.getNextInputVersionsArgsForCall)
}

func (fake *FakeJobServiceDB) GetNextInputVersionsArgsForCall(i int) (*algorithm.VersionsDB, string, []config.JobInput) {
	fake.getNextInputVersionsMutex.RLock()
	defer fake.getNextInputVersionsMutex.RUnlock()
	return fake.getNextInputVersionsArgsForCall[i].versions, fake.getNextInputVersionsArgsForCall[i].job, fake.getNextInputVersionsArgsForCall[i].inputs
}

func (fake *FakeJobServiceDB) GetNextInputVersionsReturns(result1 []db.BuildInput, result2 bool, result3 db.MissingInputReasons, result4 error) {
	fake.GetNextInputVersionsStub = nil
	fake.getNextInputVersionsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 db.MissingInputReasons
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeJobServiceDB) GetMissingInputReasons(algorithmInputConfigs algorithm.InputConfigs, inputs []config.JobInput, idealMapping algorithm.InputMapping) (db.MissingInputReasons, error) {
	var inputsCopy []config.JobInput
	if inputs != nil {
		inputsCopy = make([]config.JobInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.getMissingInputReasonsMutex.Lock()
	fake.getMissingInputReasonsArgsForCall = append(fake.getMissingInputReasonsArgsForCall, struct {
		algorithmInputConfigs algorithm.InputConfigs
		inputs                []config.JobInput
		idealMapping          algorithm.InputMapping
	}{algorithmInputConfigs, inputsCopy, idealMapping})
	fake.recordInvocation("GetMissingInputReasons", []interface{}{algorithmInputConfigs, inputsCopy, idealMapping})
	fake.getMissingInputReasonsMutex.Unlock()
	if fake.GetMissingInputReasonsStub != nil {
		return fake.GetMissingInputReasonsStub(algorithmInputConfigs, inputs, idealMapping)
	} else {
		return fake.getMissingInputReasonsReturns.result1, fake.getMissingInputReasonsReturns.result2
	}
}

func (fake *FakeJobServiceDB) GetMissingInputReasonsCallCount() int {
	fake.getMissingInputReasonsMutex.RLock()
	defer fake.getMissingInputReasonsMutex.RUnlock()
	return len(fake.getMissingInputReasonsArgsForCall)
}

func (fake *FakeJobServiceDB) GetMissingInputReasonsArgsForCall(i int) (algorithm.InputConfigs, []config.JobInput, algorithm.InputMapping) {
	fake.getMissingInputReasonsMutex.RLock()
	defer fake.getMissingInputReasonsMutex.RUnlock()
	return fake.getMissingInputReasonsArgsForCall[i].algorithmInputConfigs, fake.getMissingInputReasonsArgsForCall[i].inputs, fake.getMissingInputReasonsArgsForCall[i].idealMapping
}

func (fake *FakeJobServiceDB) GetMissingInputReasonsReturns(result1 db.MissingInputReasons, result2 error) {
	fake.GetMissingInputReasonsStub = nil
	fake.getMissingInputReasonsReturns = struct {
		result1 db.MissingInputReasons
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) GetBuildPreparation(arg1 int) (db.BuildPreparation, bool, error) {
	fake.getBuildPreparationMutex.Lock()
	fake.getBuildPreparationArgsForCall = append(fake.getBuildPreparationArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetBuildPreparation", []interface{}{arg1})
	fake.getBuildPreparationMutex.Unlock()
	if fake.GetBuildPreparationStub != nil {
		return fake.GetBuildPreparationStub(arg1)
	} else {
		return fake.getBuildPreparationReturns.result1, fake.getBuildPreparationReturns.result2, fake.getBuildPreparationReturns.result3
	}
}

func (fake *FakeJobServiceDB) GetBuildPreparationCallCount() int {
	fake.getBuildPreparationMutex.RLock()
	defer fake.getBuildPreparationMutex.RUnlock()
	return len(fake.getBuildPreparationArgsForCall)
}

func (fake *FakeJobServiceDB) GetBuildPreparationArgsForCall(i int) int {
	fake.getBuildPreparationMutex.RLock()
	defer fake.getBuildPreparationMutex.RUnlock()
	return fake.getBuildPreparationArgsForCall[i].arg1
}

func (fake *FakeJobServiceDB) GetBuildPreparationReturns(result1 db.BuildPreparation, result2 bool, result3 error) {
	fake.GetBuildPreparationStub = nil
	fake.getBuildPreparationReturns = struct {
		result1 db.BuildPreparation
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobServiceDB) GetIdealBuildInputs(jobName string) ([]db.BuildInput, error) {
	fake.getIdealBuildInputsMutex.Lock()
	fake.getIdealBuildInputsArgsForCall = append(fake.getIdealBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetIdealBuildInputs", []interface{}{jobName})
	fake.getIdealBuildInputsMutex.Unlock()
	if fake.GetIdealBuildInputsStub != nil {
		return fake.GetIdealBuildInputsStub(jobName)
	} else {
		return fake.getIdealBuildInputsReturns.result1, fake.getIdealBuildInputsReturns.result2
	}
}

func (fake *FakeJobServiceDB) GetIdealBuildInputsCallCount() int {
	fake.getIdealBuildInputsMutex.RLock()
	defer fake.getIdealBuildInputsMutex.RUnlock()
	return len(fake.getIdealBuildInputsArgsForCall)
}

func (fake *FakeJobServiceDB) GetIdealBuildInputsArgsForCall(i int) string {
	fake.getIdealBuildInputsMutex.RLock()
	defer fake.getIdealBuildInputsMutex.RUnlock()
	return fake.getIdealBuildInputsArgsForCall[i].jobName
}

func (fake *FakeJobServiceDB) GetIdealBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.GetIdealBuildInputsStub = nil
	fake.getIdealBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) GetCompromiseBuildInputs(jobName string) ([]db.BuildInput, error) {
	fake.getCompromiseBuildInputsMutex.Lock()
	fake.getCompromiseBuildInputsArgsForCall = append(fake.getCompromiseBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetCompromiseBuildInputs", []interface{}{jobName})
	fake.getCompromiseBuildInputsMutex.Unlock()
	if fake.GetCompromiseBuildInputsStub != nil {
		return fake.GetCompromiseBuildInputsStub(jobName)
	} else {
		return fake.getCompromiseBuildInputsReturns.result1, fake.getCompromiseBuildInputsReturns.result2
	}
}

func (fake *FakeJobServiceDB) GetCompromiseBuildInputsCallCount() int {
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	return len(fake.getCompromiseBuildInputsArgsForCall)
}

func (fake *FakeJobServiceDB) GetCompromiseBuildInputsArgsForCall(i int) string {
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	return fake.getCompromiseBuildInputsArgsForCall[i].jobName
}

func (fake *FakeJobServiceDB) GetCompromiseBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.GetCompromiseBuildInputsStub = nil
	fake.getCompromiseBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJobServiceDB) UseInputsForBuild(buildID int, inputs []db.BuildInput) error {
	var inputsCopy []db.BuildInput
	if inputs != nil {
		inputsCopy = make([]db.BuildInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.useInputsForBuildMutex.Lock()
	fake.useInputsForBuildArgsForCall = append(fake.useInputsForBuildArgsForCall, struct {
		buildID int
		inputs  []db.BuildInput
	}{buildID, inputsCopy})
	fake.recordInvocation("UseInputsForBuild", []interface{}{buildID, inputsCopy})
	fake.useInputsForBuildMutex.Unlock()
	if fake.UseInputsForBuildStub != nil {
		return fake.UseInputsForBuildStub(buildID, inputs)
	} else {
		return fake.useInputsForBuildReturns.result1
	}
}

func (fake *FakeJobServiceDB) UseInputsForBuildCallCount() int {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return len(fake.useInputsForBuildArgsForCall)
}

func (fake *FakeJobServiceDB) UseInputsForBuildArgsForCall(i int) (int, []db.BuildInput) {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.useInputsForBuildArgsForCall[i].buildID, fake.useInputsForBuildArgsForCall[i].inputs
}

func (fake *FakeJobServiceDB) UseInputsForBuildReturns(result1 error) {
	fake.UseInputsForBuildStub = nil
	fake.useInputsForBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobServiceDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.updateBuildPreparationMutex.RLock()
	defer fake.updateBuildPreparationMutex.RUnlock()
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.getNextInputVersionsMutex.RLock()
	defer fake.getNextInputVersionsMutex.RUnlock()
	fake.getMissingInputReasonsMutex.RLock()
	defer fake.getMissingInputReasonsMutex.RUnlock()
	fake.getBuildPreparationMutex.RLock()
	defer fake.getBuildPreparationMutex.RUnlock()
	fake.getIdealBuildInputsMutex.RLock()
	defer fake.getIdealBuildInputsMutex.RUnlock()
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeJobServiceDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scheduler.JobServiceDB = new(FakeJobServiceDB)
