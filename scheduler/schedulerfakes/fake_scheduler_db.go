// This file was generated by counterfeiter
package schedulerfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/scheduler"
)

type FakeSchedulerDB struct {
	LeaseSchedulingStub        func(lager.Logger, time.Duration) (db.Lease, bool, error)
	leaseSchedulingMutex       sync.RWMutex
	leaseSchedulingArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	leaseSchedulingReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	GetPipelineNameStub        func() string
	getPipelineNameMutex       sync.RWMutex
	getPipelineNameArgsForCall []struct{}
	getPipelineNameReturns     struct {
		result1 string
	}
	GetConfigStub        func() (atc.Config, db.ConfigVersion, bool, error)
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct{}
	getConfigReturns     struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}
	CreateJobBuildStub        func(job string) (db.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		job string
	}
	createJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	EnsurePendingBuildExistsStub        func(jobName string) error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct {
		jobName string
	}
	ensurePendingBuildExistsReturns struct {
		result1 error
	}
	LeaseResourceCheckingForJobStub        func(logger lager.Logger, job string, interval time.Duration) (db.Lease, bool, error)
	leaseResourceCheckingForJobMutex       sync.RWMutex
	leaseResourceCheckingForJobArgsForCall []struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}
	leaseResourceCheckingForJobReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchedulerDB) LeaseScheduling(arg1 lager.Logger, arg2 time.Duration) (db.Lease, bool, error) {
	fake.leaseSchedulingMutex.Lock()
	fake.leaseSchedulingArgsForCall = append(fake.leaseSchedulingArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("LeaseScheduling", []interface{}{arg1, arg2})
	fake.leaseSchedulingMutex.Unlock()
	if fake.LeaseSchedulingStub != nil {
		return fake.LeaseSchedulingStub(arg1, arg2)
	} else {
		return fake.leaseSchedulingReturns.result1, fake.leaseSchedulingReturns.result2, fake.leaseSchedulingReturns.result3
	}
}

func (fake *FakeSchedulerDB) LeaseSchedulingCallCount() int {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return len(fake.leaseSchedulingArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseSchedulingArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return fake.leaseSchedulingArgsForCall[i].arg1, fake.leaseSchedulingArgsForCall[i].arg2
}

func (fake *FakeSchedulerDB) LeaseSchedulingReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseSchedulingStub = nil
	fake.leaseSchedulingReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	} else {
		return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
	}
}

func (fake *FakeSchedulerDB) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakeSchedulerDB) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetPipelineName() string {
	fake.getPipelineNameMutex.Lock()
	fake.getPipelineNameArgsForCall = append(fake.getPipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineName", []interface{}{})
	fake.getPipelineNameMutex.Unlock()
	if fake.GetPipelineNameStub != nil {
		return fake.GetPipelineNameStub()
	} else {
		return fake.getPipelineNameReturns.result1
	}
}

func (fake *FakeSchedulerDB) GetPipelineNameCallCount() int {
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return len(fake.getPipelineNameArgsForCall)
}

func (fake *FakeSchedulerDB) GetPipelineNameReturns(result1 string) {
	fake.GetPipelineNameStub = nil
	fake.getPipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSchedulerDB) GetConfig() (atc.Config, db.ConfigVersion, bool, error) {
	fake.getConfigMutex.Lock()
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct{}{})
	fake.recordInvocation("GetConfig", []interface{}{})
	fake.getConfigMutex.Unlock()
	if fake.GetConfigStub != nil {
		return fake.GetConfigStub()
	} else {
		return fake.getConfigReturns.result1, fake.getConfigReturns.result2, fake.getConfigReturns.result3, fake.getConfigReturns.result4
	}
}

func (fake *FakeSchedulerDB) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeSchedulerDB) GetConfigReturns(result1 atc.Config, result2 db.ConfigVersion, result3 bool, result4 error) {
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeSchedulerDB) CreateJobBuild(job string) (db.Build, error) {
	fake.createJobBuildMutex.Lock()
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("CreateJobBuild", []interface{}{job})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(job)
	} else {
		return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
	}
}

func (fake *FakeSchedulerDB) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeSchedulerDB) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].job
}

func (fake *FakeSchedulerDB) CreateJobBuildReturns(result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExists(jobName string) error {
	fake.ensurePendingBuildExistsMutex.Lock()
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{jobName})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub(jobName)
	} else {
		return fake.ensurePendingBuildExistsReturns.result1
	}
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsArgsForCall(i int) string {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return fake.ensurePendingBuildExistsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsReturns(result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJob(logger lager.Logger, job string, interval time.Duration) (db.Lease, bool, error) {
	fake.leaseResourceCheckingForJobMutex.Lock()
	fake.leaseResourceCheckingForJobArgsForCall = append(fake.leaseResourceCheckingForJobArgsForCall, struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}{logger, job, interval})
	fake.recordInvocation("LeaseResourceCheckingForJob", []interface{}{logger, job, interval})
	fake.leaseResourceCheckingForJobMutex.Unlock()
	if fake.LeaseResourceCheckingForJobStub != nil {
		return fake.LeaseResourceCheckingForJobStub(logger, job, interval)
	} else {
		return fake.leaseResourceCheckingForJobReturns.result1, fake.leaseResourceCheckingForJobReturns.result2, fake.leaseResourceCheckingForJobReturns.result3
	}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobCallCount() int {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return len(fake.leaseResourceCheckingForJobArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return fake.leaseResourceCheckingForJobArgsForCall[i].logger, fake.leaseResourceCheckingForJobArgsForCall[i].job, fake.leaseResourceCheckingForJobArgsForCall[i].interval
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseResourceCheckingForJobStub = nil
	fake.leaseResourceCheckingForJobReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSchedulerDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scheduler.SchedulerDB = new(FakeSchedulerDB)
