// This file was generated by counterfeiter
package schedulerfakes

import (
	"sync"
	"time"

	"github.com/concourse/atc"
	"github.com/concourse/atc/config"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/scheduler"
	"github.com/pivotal-golang/lager"
)

type FakeSchedulerDB struct {
	LeaseSchedulingStub        func(lager.Logger, time.Duration) (db.Lease, bool, error)
	leaseSchedulingMutex       sync.RWMutex
	leaseSchedulingArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	leaseSchedulingReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	GetPipelineNameStub        func() string
	getPipelineNameMutex       sync.RWMutex
	getPipelineNameArgsForCall []struct{}
	getPipelineNameReturns     struct {
		result1 string
	}
	GetConfigStub        func() (atc.Config, db.ConfigVersion, bool, error)
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct{}
	getConfigReturns     struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}
	GetAlgorithmInputConfigsStub        func(db *algorithm.VersionsDB, jobName string, inputs []config.JobInput) (algorithm.InputConfigs, error)
	getAlgorithmInputConfigsMutex       sync.RWMutex
	getAlgorithmInputConfigsArgsForCall []struct {
		db      *algorithm.VersionsDB
		jobName string
		inputs  []config.JobInput
	}
	getAlgorithmInputConfigsReturns struct {
		result1 algorithm.InputConfigs
		result2 error
	}
	EnsurePendingBuildExistsStub        func(jobName string) error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct {
		jobName string
	}
	ensurePendingBuildExistsReturns struct {
		result1 error
	}
	CreateJobBuildStub        func(jobName string) (db.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		jobName string
	}
	createJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	GetNextPendingBuildStub        func(job string) (db.Build, bool, error)
	getNextPendingBuildMutex       sync.RWMutex
	getNextPendingBuildArgsForCall []struct {
		job string
	}
	getNextPendingBuildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	SaveIndependentInputMappingStub        func(inputVersions algorithm.InputMapping, jobName string) error
	saveIndependentInputMappingMutex       sync.RWMutex
	saveIndependentInputMappingArgsForCall []struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}
	saveIndependentInputMappingReturns struct {
		result1 error
	}
	SaveNextInputMappingStub        func(inputVersions algorithm.InputMapping, jobName string) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	DeleteNextInputMappingStub        func(jobName string) error
	deleteNextInputMappingMutex       sync.RWMutex
	deleteNextInputMappingArgsForCall []struct {
		jobName string
	}
	deleteNextInputMappingReturns struct {
		result1 error
	}
	GetNextBuildInputsStub        func(jobName string) ([]db.BuildInput, bool, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct {
		jobName string
	}
	getNextBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	LeaseResourceCheckingForJobStub        func(logger lager.Logger, job string, interval time.Duration) (db.Lease, error)
	leaseResourceCheckingForJobMutex       sync.RWMutex
	leaseResourceCheckingForJobArgsForCall []struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}
	leaseResourceCheckingForJobReturns struct {
		result1 db.Lease
		result2 error
	}
	IsPausedStub        func() (bool, error)
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct{}
	isPausedReturns     struct {
		result1 bool
		result2 error
	}
	GetJobStub        func(job string) (db.SavedJob, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		job string
	}
	getJobReturns struct {
		result1 db.SavedJob
		result2 error
	}
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	UpdateBuildToScheduledStub        func(int) (bool, error)
	updateBuildToScheduledMutex       sync.RWMutex
	updateBuildToScheduledArgsForCall []struct {
		arg1 int
	}
	updateBuildToScheduledReturns struct {
		result1 bool
		result2 error
	}
	UseInputsForBuildStub        func(buildID int, inputs []db.BuildInput) error
	useInputsForBuildMutex       sync.RWMutex
	useInputsForBuildArgsForCall []struct {
		buildID int
		inputs  []db.BuildInput
	}
	useInputsForBuildReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchedulerDB) LeaseScheduling(arg1 lager.Logger, arg2 time.Duration) (db.Lease, bool, error) {
	fake.leaseSchedulingMutex.Lock()
	fake.leaseSchedulingArgsForCall = append(fake.leaseSchedulingArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("LeaseScheduling", []interface{}{arg1, arg2})
	fake.leaseSchedulingMutex.Unlock()
	if fake.LeaseSchedulingStub != nil {
		return fake.LeaseSchedulingStub(arg1, arg2)
	} else {
		return fake.leaseSchedulingReturns.result1, fake.leaseSchedulingReturns.result2, fake.leaseSchedulingReturns.result3
	}
}

func (fake *FakeSchedulerDB) LeaseSchedulingCallCount() int {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return len(fake.leaseSchedulingArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseSchedulingArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return fake.leaseSchedulingArgsForCall[i].arg1, fake.leaseSchedulingArgsForCall[i].arg2
}

func (fake *FakeSchedulerDB) LeaseSchedulingReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseSchedulingStub = nil
	fake.leaseSchedulingReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	} else {
		return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
	}
}

func (fake *FakeSchedulerDB) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakeSchedulerDB) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetPipelineName() string {
	fake.getPipelineNameMutex.Lock()
	fake.getPipelineNameArgsForCall = append(fake.getPipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineName", []interface{}{})
	fake.getPipelineNameMutex.Unlock()
	if fake.GetPipelineNameStub != nil {
		return fake.GetPipelineNameStub()
	} else {
		return fake.getPipelineNameReturns.result1
	}
}

func (fake *FakeSchedulerDB) GetPipelineNameCallCount() int {
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return len(fake.getPipelineNameArgsForCall)
}

func (fake *FakeSchedulerDB) GetPipelineNameReturns(result1 string) {
	fake.GetPipelineNameStub = nil
	fake.getPipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSchedulerDB) GetConfig() (atc.Config, db.ConfigVersion, bool, error) {
	fake.getConfigMutex.Lock()
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct{}{})
	fake.recordInvocation("GetConfig", []interface{}{})
	fake.getConfigMutex.Unlock()
	if fake.GetConfigStub != nil {
		return fake.GetConfigStub()
	} else {
		return fake.getConfigReturns.result1, fake.getConfigReturns.result2, fake.getConfigReturns.result3, fake.getConfigReturns.result4
	}
}

func (fake *FakeSchedulerDB) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeSchedulerDB) GetConfigReturns(result1 atc.Config, result2 db.ConfigVersion, result3 bool, result4 error) {
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigs(db *algorithm.VersionsDB, jobName string, inputs []config.JobInput) (algorithm.InputConfigs, error) {
	var inputsCopy []config.JobInput
	if inputs != nil {
		inputsCopy = make([]config.JobInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.getAlgorithmInputConfigsMutex.Lock()
	fake.getAlgorithmInputConfigsArgsForCall = append(fake.getAlgorithmInputConfigsArgsForCall, struct {
		db      *algorithm.VersionsDB
		jobName string
		inputs  []config.JobInput
	}{db, jobName, inputsCopy})
	fake.recordInvocation("GetAlgorithmInputConfigs", []interface{}{db, jobName, inputsCopy})
	fake.getAlgorithmInputConfigsMutex.Unlock()
	if fake.GetAlgorithmInputConfigsStub != nil {
		return fake.GetAlgorithmInputConfigsStub(db, jobName, inputs)
	} else {
		return fake.getAlgorithmInputConfigsReturns.result1, fake.getAlgorithmInputConfigsReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsCallCount() int {
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	return len(fake.getAlgorithmInputConfigsArgsForCall)
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsArgsForCall(i int) (*algorithm.VersionsDB, string, []config.JobInput) {
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	return fake.getAlgorithmInputConfigsArgsForCall[i].db, fake.getAlgorithmInputConfigsArgsForCall[i].jobName, fake.getAlgorithmInputConfigsArgsForCall[i].inputs
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsReturns(result1 algorithm.InputConfigs, result2 error) {
	fake.GetAlgorithmInputConfigsStub = nil
	fake.getAlgorithmInputConfigsReturns = struct {
		result1 algorithm.InputConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExists(jobName string) error {
	fake.ensurePendingBuildExistsMutex.Lock()
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{jobName})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub(jobName)
	} else {
		return fake.ensurePendingBuildExistsReturns.result1
	}
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsArgsForCall(i int) string {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return fake.ensurePendingBuildExistsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) EnsurePendingBuildExistsReturns(result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) CreateJobBuild(jobName string) (db.Build, error) {
	fake.createJobBuildMutex.Lock()
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("CreateJobBuild", []interface{}{jobName})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(jobName)
	} else {
		return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
	}
}

func (fake *FakeSchedulerDB) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeSchedulerDB) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) CreateJobBuildReturns(result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetNextPendingBuild(job string) (db.Build, bool, error) {
	fake.getNextPendingBuildMutex.Lock()
	fake.getNextPendingBuildArgsForCall = append(fake.getNextPendingBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetNextPendingBuild", []interface{}{job})
	fake.getNextPendingBuildMutex.Unlock()
	if fake.GetNextPendingBuildStub != nil {
		return fake.GetNextPendingBuildStub(job)
	} else {
		return fake.getNextPendingBuildReturns.result1, fake.getNextPendingBuildReturns.result2, fake.getNextPendingBuildReturns.result3
	}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildCallCount() int {
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	return len(fake.getNextPendingBuildArgsForCall)
}

func (fake *FakeSchedulerDB) GetNextPendingBuildArgsForCall(i int) string {
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	return fake.getNextPendingBuildArgsForCall[i].job
}

func (fake *FakeSchedulerDB) GetNextPendingBuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildStub = nil
	fake.getNextPendingBuildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) SaveIndependentInputMapping(inputVersions algorithm.InputMapping, jobName string) error {
	fake.saveIndependentInputMappingMutex.Lock()
	fake.saveIndependentInputMappingArgsForCall = append(fake.saveIndependentInputMappingArgsForCall, struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}{inputVersions, jobName})
	fake.recordInvocation("SaveIndependentInputMapping", []interface{}{inputVersions, jobName})
	fake.saveIndependentInputMappingMutex.Unlock()
	if fake.SaveIndependentInputMappingStub != nil {
		return fake.SaveIndependentInputMappingStub(inputVersions, jobName)
	} else {
		return fake.saveIndependentInputMappingReturns.result1
	}
}

func (fake *FakeSchedulerDB) SaveIndependentInputMappingCallCount() int {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return len(fake.saveIndependentInputMappingArgsForCall)
}

func (fake *FakeSchedulerDB) SaveIndependentInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return fake.saveIndependentInputMappingArgsForCall[i].inputVersions, fake.saveIndependentInputMappingArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) SaveIndependentInputMappingReturns(result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	fake.saveIndependentInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) SaveNextInputMapping(inputVersions algorithm.InputMapping, jobName string) error {
	fake.saveNextInputMappingMutex.Lock()
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}{inputVersions, jobName})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{inputVersions, jobName})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(inputVersions, jobName)
	} else {
		return fake.saveNextInputMappingReturns.result1
	}
}

func (fake *FakeSchedulerDB) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakeSchedulerDB) SaveNextInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return fake.saveNextInputMappingArgsForCall[i].inputVersions, fake.saveNextInputMappingArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) SaveNextInputMappingReturns(result1 error) {
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) DeleteNextInputMapping(jobName string) error {
	fake.deleteNextInputMappingMutex.Lock()
	fake.deleteNextInputMappingArgsForCall = append(fake.deleteNextInputMappingArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("DeleteNextInputMapping", []interface{}{jobName})
	fake.deleteNextInputMappingMutex.Unlock()
	if fake.DeleteNextInputMappingStub != nil {
		return fake.DeleteNextInputMappingStub(jobName)
	} else {
		return fake.deleteNextInputMappingReturns.result1
	}
}

func (fake *FakeSchedulerDB) DeleteNextInputMappingCallCount() int {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return len(fake.deleteNextInputMappingArgsForCall)
}

func (fake *FakeSchedulerDB) DeleteNextInputMappingArgsForCall(i int) string {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return fake.deleteNextInputMappingArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) DeleteNextInputMappingReturns(result1 error) {
	fake.DeleteNextInputMappingStub = nil
	fake.deleteNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) GetNextBuildInputs(jobName string) ([]db.BuildInput, bool, error) {
	fake.getNextBuildInputsMutex.Lock()
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{jobName})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub(jobName)
	} else {
		return fake.getNextBuildInputsReturns.result1, fake.getNextBuildInputsReturns.result2, fake.getNextBuildInputsReturns.result3
	}
}

func (fake *FakeSchedulerDB) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakeSchedulerDB) GetNextBuildInputsArgsForCall(i int) string {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return fake.getNextBuildInputsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) GetNextBuildInputsReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJob(logger lager.Logger, job string, interval time.Duration) (db.Lease, error) {
	fake.leaseResourceCheckingForJobMutex.Lock()
	fake.leaseResourceCheckingForJobArgsForCall = append(fake.leaseResourceCheckingForJobArgsForCall, struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}{logger, job, interval})
	fake.recordInvocation("LeaseResourceCheckingForJob", []interface{}{logger, job, interval})
	fake.leaseResourceCheckingForJobMutex.Unlock()
	if fake.LeaseResourceCheckingForJobStub != nil {
		return fake.LeaseResourceCheckingForJobStub(logger, job, interval)
	} else {
		return fake.leaseResourceCheckingForJobReturns.result1, fake.leaseResourceCheckingForJobReturns.result2
	}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobCallCount() int {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return len(fake.leaseResourceCheckingForJobArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return fake.leaseResourceCheckingForJobArgsForCall[i].logger, fake.leaseResourceCheckingForJobArgsForCall[i].job, fake.leaseResourceCheckingForJobArgsForCall[i].interval
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobReturns(result1 db.Lease, result2 error) {
	fake.LeaseResourceCheckingForJobStub = nil
	fake.leaseResourceCheckingForJobReturns = struct {
		result1 db.Lease
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) IsPaused() (bool, error) {
	fake.isPausedMutex.Lock()
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct{}{})
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if fake.IsPausedStub != nil {
		return fake.IsPausedStub()
	} else {
		return fake.isPausedReturns.result1, fake.isPausedReturns.result2
	}
}

func (fake *FakeSchedulerDB) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *FakeSchedulerDB) IsPausedReturns(result1 bool, result2 error) {
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetJob(job string) (db.SavedJob, error) {
	fake.getJobMutex.Lock()
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJob", []interface{}{job})
	fake.getJobMutex.Unlock()
	if fake.GetJobStub != nil {
		return fake.GetJobStub(job)
	} else {
		return fake.getJobReturns.result1, fake.getJobReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeSchedulerDB) GetJobArgsForCall(i int) string {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return fake.getJobArgsForCall[i].job
}

func (fake *FakeSchedulerDB) GetJobReturns(result1 db.SavedJob, result2 error) {
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 db.SavedJob
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
	}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduled(arg1 int) (bool, error) {
	fake.updateBuildToScheduledMutex.Lock()
	fake.updateBuildToScheduledArgsForCall = append(fake.updateBuildToScheduledArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("UpdateBuildToScheduled", []interface{}{arg1})
	fake.updateBuildToScheduledMutex.Unlock()
	if fake.UpdateBuildToScheduledStub != nil {
		return fake.UpdateBuildToScheduledStub(arg1)
	} else {
		return fake.updateBuildToScheduledReturns.result1, fake.updateBuildToScheduledReturns.result2
	}
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledCallCount() int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return len(fake.updateBuildToScheduledArgsForCall)
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledArgsForCall(i int) int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return fake.updateBuildToScheduledArgsForCall[i].arg1
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledReturns(result1 bool, result2 error) {
	fake.UpdateBuildToScheduledStub = nil
	fake.updateBuildToScheduledReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) UseInputsForBuild(buildID int, inputs []db.BuildInput) error {
	var inputsCopy []db.BuildInput
	if inputs != nil {
		inputsCopy = make([]db.BuildInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.useInputsForBuildMutex.Lock()
	fake.useInputsForBuildArgsForCall = append(fake.useInputsForBuildArgsForCall, struct {
		buildID int
		inputs  []db.BuildInput
	}{buildID, inputsCopy})
	fake.recordInvocation("UseInputsForBuild", []interface{}{buildID, inputsCopy})
	fake.useInputsForBuildMutex.Unlock()
	if fake.UseInputsForBuildStub != nil {
		return fake.UseInputsForBuildStub(buildID, inputs)
	} else {
		return fake.useInputsForBuildReturns.result1
	}
}

func (fake *FakeSchedulerDB) UseInputsForBuildCallCount() int {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return len(fake.useInputsForBuildArgsForCall)
}

func (fake *FakeSchedulerDB) UseInputsForBuildArgsForCall(i int) (int, []db.BuildInput) {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.useInputsForBuildArgsForCall[i].buildID, fake.useInputsForBuildArgsForCall[i].inputs
}

func (fake *FakeSchedulerDB) UseInputsForBuildReturns(result1 error) {
	fake.UseInputsForBuildStub = nil
	fake.useInputsForBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSchedulerDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scheduler.SchedulerDB = new(FakeSchedulerDB)
