// This file was generated by counterfeiter
package schedulerfakes

import (
	"sync"
	"time"

	"github.com/concourse/atc"
	"github.com/concourse/atc/config"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/scheduler"
	"github.com/pivotal-golang/lager"
)

type FakeSchedulerDB struct {
	CreateJobBuildStub        func(jobName string, requireResourceChecking bool) (db.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		jobName                 string
		requireResourceChecking bool
	}
	createJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	GetNextPendingBuildStub        func(job string) (db.Build, bool, error)
	getNextPendingBuildMutex       sync.RWMutex
	getNextPendingBuildArgsForCall []struct {
		job string
	}
	getNextPendingBuildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	IsPausedStub        func() (bool, error)
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct{}
	isPausedReturns     struct {
		result1 bool
		result2 error
	}
	GetConfigStub        func() (atc.Config, db.ConfigVersion, bool, error)
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct{}
	getConfigReturns     struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}
	GetJobStub        func(job string) (db.SavedJob, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		job string
	}
	getJobReturns struct {
		result1 db.SavedJob
		result2 error
	}
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	GetCompromiseBuildInputsStub        func(jobName string) ([]db.BuildInput, error)
	getCompromiseBuildInputsMutex       sync.RWMutex
	getCompromiseBuildInputsArgsForCall []struct {
		jobName string
	}
	getCompromiseBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 error
	}
	UpdateBuildToScheduledStub        func(int) (bool, error)
	updateBuildToScheduledMutex       sync.RWMutex
	updateBuildToScheduledArgsForCall []struct {
		arg1 int
	}
	updateBuildToScheduledReturns struct {
		result1 bool
		result2 error
	}
	UseInputsForBuildStub        func(buildID int, inputs []db.BuildInput) error
	useInputsForBuildMutex       sync.RWMutex
	useInputsForBuildArgsForCall []struct {
		buildID int
		inputs  []db.BuildInput
	}
	useInputsForBuildReturns struct {
		result1 error
	}
	LeaseResourceCheckingForJobStub        func(logger lager.Logger, job string, interval time.Duration) (db.Lease, bool, error)
	leaseResourceCheckingForJobMutex       sync.RWMutex
	leaseResourceCheckingForJobArgsForCall []struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}
	leaseResourceCheckingForJobReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
	LeaseResourceCheckingForJobAcquiredStub        func(jobName string) (bool, error)
	leaseResourceCheckingForJobAcquiredMutex       sync.RWMutex
	leaseResourceCheckingForJobAcquiredArgsForCall []struct {
		jobName string
	}
	leaseResourceCheckingForJobAcquiredReturns struct {
		result1 bool
		result2 error
	}
	GetAlgorithmInputConfigsStub        func(db *algorithm.VersionsDB, jobName string, inputs []config.JobInput) (algorithm.InputConfigs, error)
	getAlgorithmInputConfigsMutex       sync.RWMutex
	getAlgorithmInputConfigsArgsForCall []struct {
		db      *algorithm.VersionsDB
		jobName string
		inputs  []config.JobInput
	}
	getAlgorithmInputConfigsReturns struct {
		result1 algorithm.InputConfigs
		result2 error
	}
	SaveIdealInputVersionsStub        func(inputVersions algorithm.InputMapping, jobName string) error
	saveIdealInputVersionsMutex       sync.RWMutex
	saveIdealInputVersionsArgsForCall []struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}
	saveIdealInputVersionsReturns struct {
		result1 error
	}
	SaveCompromiseInputVersionsStub        func(inputVersions algorithm.InputMapping, jobName string) error
	saveCompromiseInputVersionsMutex       sync.RWMutex
	saveCompromiseInputVersionsArgsForCall []struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}
	saveCompromiseInputVersionsReturns struct {
		result1 error
	}
	DeleteCompromiseInputVersionsStub        func(jobName string) error
	deleteCompromiseInputVersionsMutex       sync.RWMutex
	deleteCompromiseInputVersionsArgsForCall []struct {
		jobName string
	}
	deleteCompromiseInputVersionsReturns struct {
		result1 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	LeaseSchedulingStub        func(lager.Logger, time.Duration) (db.Lease, bool, error)
	leaseSchedulingMutex       sync.RWMutex
	leaseSchedulingArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	leaseSchedulingReturns struct {
		result1 db.Lease
		result2 bool
		result3 error
	}
	GetPipelineNameStub        func() string
	getPipelineNameMutex       sync.RWMutex
	getPipelineNameArgsForCall []struct{}
	getPipelineNameReturns     struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchedulerDB) CreateJobBuild(jobName string, requireResourceChecking bool) (db.Build, error) {
	fake.createJobBuildMutex.Lock()
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		jobName                 string
		requireResourceChecking bool
	}{jobName, requireResourceChecking})
	fake.recordInvocation("CreateJobBuild", []interface{}{jobName, requireResourceChecking})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(jobName, requireResourceChecking)
	} else {
		return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
	}
}

func (fake *FakeSchedulerDB) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeSchedulerDB) CreateJobBuildArgsForCall(i int) (string, bool) {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].jobName, fake.createJobBuildArgsForCall[i].requireResourceChecking
}

func (fake *FakeSchedulerDB) CreateJobBuildReturns(result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetNextPendingBuild(job string) (db.Build, bool, error) {
	fake.getNextPendingBuildMutex.Lock()
	fake.getNextPendingBuildArgsForCall = append(fake.getNextPendingBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetNextPendingBuild", []interface{}{job})
	fake.getNextPendingBuildMutex.Unlock()
	if fake.GetNextPendingBuildStub != nil {
		return fake.GetNextPendingBuildStub(job)
	} else {
		return fake.getNextPendingBuildReturns.result1, fake.getNextPendingBuildReturns.result2, fake.getNextPendingBuildReturns.result3
	}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildCallCount() int {
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	return len(fake.getNextPendingBuildArgsForCall)
}

func (fake *FakeSchedulerDB) GetNextPendingBuildArgsForCall(i int) string {
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	return fake.getNextPendingBuildArgsForCall[i].job
}

func (fake *FakeSchedulerDB) GetNextPendingBuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildStub = nil
	fake.getNextPendingBuildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) IsPaused() (bool, error) {
	fake.isPausedMutex.Lock()
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct{}{})
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if fake.IsPausedStub != nil {
		return fake.IsPausedStub()
	} else {
		return fake.isPausedReturns.result1, fake.isPausedReturns.result2
	}
}

func (fake *FakeSchedulerDB) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *FakeSchedulerDB) IsPausedReturns(result1 bool, result2 error) {
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetConfig() (atc.Config, db.ConfigVersion, bool, error) {
	fake.getConfigMutex.Lock()
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct{}{})
	fake.recordInvocation("GetConfig", []interface{}{})
	fake.getConfigMutex.Unlock()
	if fake.GetConfigStub != nil {
		return fake.GetConfigStub()
	} else {
		return fake.getConfigReturns.result1, fake.getConfigReturns.result2, fake.getConfigReturns.result3, fake.getConfigReturns.result4
	}
}

func (fake *FakeSchedulerDB) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeSchedulerDB) GetConfigReturns(result1 atc.Config, result2 db.ConfigVersion, result3 bool, result4 error) {
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 atc.Config
		result2 db.ConfigVersion
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeSchedulerDB) GetJob(job string) (db.SavedJob, error) {
	fake.getJobMutex.Lock()
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJob", []interface{}{job})
	fake.getJobMutex.Unlock()
	if fake.GetJobStub != nil {
		return fake.GetJobStub(job)
	} else {
		return fake.getJobReturns.result1, fake.getJobReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeSchedulerDB) GetJobArgsForCall(i int) string {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return fake.getJobArgsForCall[i].job
}

func (fake *FakeSchedulerDB) GetJobReturns(result1 db.SavedJob, result2 error) {
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 db.SavedJob
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeSchedulerDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
	}
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeSchedulerDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) GetCompromiseBuildInputs(jobName string) ([]db.BuildInput, error) {
	fake.getCompromiseBuildInputsMutex.Lock()
	fake.getCompromiseBuildInputsArgsForCall = append(fake.getCompromiseBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetCompromiseBuildInputs", []interface{}{jobName})
	fake.getCompromiseBuildInputsMutex.Unlock()
	if fake.GetCompromiseBuildInputsStub != nil {
		return fake.GetCompromiseBuildInputsStub(jobName)
	} else {
		return fake.getCompromiseBuildInputsReturns.result1, fake.getCompromiseBuildInputsReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetCompromiseBuildInputsCallCount() int {
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	return len(fake.getCompromiseBuildInputsArgsForCall)
}

func (fake *FakeSchedulerDB) GetCompromiseBuildInputsArgsForCall(i int) string {
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	return fake.getCompromiseBuildInputsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) GetCompromiseBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.GetCompromiseBuildInputsStub = nil
	fake.getCompromiseBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduled(arg1 int) (bool, error) {
	fake.updateBuildToScheduledMutex.Lock()
	fake.updateBuildToScheduledArgsForCall = append(fake.updateBuildToScheduledArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("UpdateBuildToScheduled", []interface{}{arg1})
	fake.updateBuildToScheduledMutex.Unlock()
	if fake.UpdateBuildToScheduledStub != nil {
		return fake.UpdateBuildToScheduledStub(arg1)
	} else {
		return fake.updateBuildToScheduledReturns.result1, fake.updateBuildToScheduledReturns.result2
	}
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledCallCount() int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return len(fake.updateBuildToScheduledArgsForCall)
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledArgsForCall(i int) int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return fake.updateBuildToScheduledArgsForCall[i].arg1
}

func (fake *FakeSchedulerDB) UpdateBuildToScheduledReturns(result1 bool, result2 error) {
	fake.UpdateBuildToScheduledStub = nil
	fake.updateBuildToScheduledReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) UseInputsForBuild(buildID int, inputs []db.BuildInput) error {
	var inputsCopy []db.BuildInput
	if inputs != nil {
		inputsCopy = make([]db.BuildInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.useInputsForBuildMutex.Lock()
	fake.useInputsForBuildArgsForCall = append(fake.useInputsForBuildArgsForCall, struct {
		buildID int
		inputs  []db.BuildInput
	}{buildID, inputsCopy})
	fake.recordInvocation("UseInputsForBuild", []interface{}{buildID, inputsCopy})
	fake.useInputsForBuildMutex.Unlock()
	if fake.UseInputsForBuildStub != nil {
		return fake.UseInputsForBuildStub(buildID, inputs)
	} else {
		return fake.useInputsForBuildReturns.result1
	}
}

func (fake *FakeSchedulerDB) UseInputsForBuildCallCount() int {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return len(fake.useInputsForBuildArgsForCall)
}

func (fake *FakeSchedulerDB) UseInputsForBuildArgsForCall(i int) (int, []db.BuildInput) {
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	return fake.useInputsForBuildArgsForCall[i].buildID, fake.useInputsForBuildArgsForCall[i].inputs
}

func (fake *FakeSchedulerDB) UseInputsForBuildReturns(result1 error) {
	fake.UseInputsForBuildStub = nil
	fake.useInputsForBuildReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJob(logger lager.Logger, job string, interval time.Duration) (db.Lease, bool, error) {
	fake.leaseResourceCheckingForJobMutex.Lock()
	fake.leaseResourceCheckingForJobArgsForCall = append(fake.leaseResourceCheckingForJobArgsForCall, struct {
		logger   lager.Logger
		job      string
		interval time.Duration
	}{logger, job, interval})
	fake.recordInvocation("LeaseResourceCheckingForJob", []interface{}{logger, job, interval})
	fake.leaseResourceCheckingForJobMutex.Unlock()
	if fake.LeaseResourceCheckingForJobStub != nil {
		return fake.LeaseResourceCheckingForJobStub(logger, job, interval)
	} else {
		return fake.leaseResourceCheckingForJobReturns.result1, fake.leaseResourceCheckingForJobReturns.result2, fake.leaseResourceCheckingForJobReturns.result3
	}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobCallCount() int {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return len(fake.leaseResourceCheckingForJobArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	return fake.leaseResourceCheckingForJobArgsForCall[i].logger, fake.leaseResourceCheckingForJobArgsForCall[i].job, fake.leaseResourceCheckingForJobArgsForCall[i].interval
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseResourceCheckingForJobStub = nil
	fake.leaseResourceCheckingForJobReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobAcquired(jobName string) (bool, error) {
	fake.leaseResourceCheckingForJobAcquiredMutex.Lock()
	fake.leaseResourceCheckingForJobAcquiredArgsForCall = append(fake.leaseResourceCheckingForJobAcquiredArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("LeaseResourceCheckingForJobAcquired", []interface{}{jobName})
	fake.leaseResourceCheckingForJobAcquiredMutex.Unlock()
	if fake.LeaseResourceCheckingForJobAcquiredStub != nil {
		return fake.LeaseResourceCheckingForJobAcquiredStub(jobName)
	} else {
		return fake.leaseResourceCheckingForJobAcquiredReturns.result1, fake.leaseResourceCheckingForJobAcquiredReturns.result2
	}
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobAcquiredCallCount() int {
	fake.leaseResourceCheckingForJobAcquiredMutex.RLock()
	defer fake.leaseResourceCheckingForJobAcquiredMutex.RUnlock()
	return len(fake.leaseResourceCheckingForJobAcquiredArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobAcquiredArgsForCall(i int) string {
	fake.leaseResourceCheckingForJobAcquiredMutex.RLock()
	defer fake.leaseResourceCheckingForJobAcquiredMutex.RUnlock()
	return fake.leaseResourceCheckingForJobAcquiredArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) LeaseResourceCheckingForJobAcquiredReturns(result1 bool, result2 error) {
	fake.LeaseResourceCheckingForJobAcquiredStub = nil
	fake.leaseResourceCheckingForJobAcquiredReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigs(db *algorithm.VersionsDB, jobName string, inputs []config.JobInput) (algorithm.InputConfigs, error) {
	var inputsCopy []config.JobInput
	if inputs != nil {
		inputsCopy = make([]config.JobInput, len(inputs))
		copy(inputsCopy, inputs)
	}
	fake.getAlgorithmInputConfigsMutex.Lock()
	fake.getAlgorithmInputConfigsArgsForCall = append(fake.getAlgorithmInputConfigsArgsForCall, struct {
		db      *algorithm.VersionsDB
		jobName string
		inputs  []config.JobInput
	}{db, jobName, inputsCopy})
	fake.recordInvocation("GetAlgorithmInputConfigs", []interface{}{db, jobName, inputsCopy})
	fake.getAlgorithmInputConfigsMutex.Unlock()
	if fake.GetAlgorithmInputConfigsStub != nil {
		return fake.GetAlgorithmInputConfigsStub(db, jobName, inputs)
	} else {
		return fake.getAlgorithmInputConfigsReturns.result1, fake.getAlgorithmInputConfigsReturns.result2
	}
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsCallCount() int {
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	return len(fake.getAlgorithmInputConfigsArgsForCall)
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsArgsForCall(i int) (*algorithm.VersionsDB, string, []config.JobInput) {
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	return fake.getAlgorithmInputConfigsArgsForCall[i].db, fake.getAlgorithmInputConfigsArgsForCall[i].jobName, fake.getAlgorithmInputConfigsArgsForCall[i].inputs
}

func (fake *FakeSchedulerDB) GetAlgorithmInputConfigsReturns(result1 algorithm.InputConfigs, result2 error) {
	fake.GetAlgorithmInputConfigsStub = nil
	fake.getAlgorithmInputConfigsReturns = struct {
		result1 algorithm.InputConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) SaveIdealInputVersions(inputVersions algorithm.InputMapping, jobName string) error {
	fake.saveIdealInputVersionsMutex.Lock()
	fake.saveIdealInputVersionsArgsForCall = append(fake.saveIdealInputVersionsArgsForCall, struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}{inputVersions, jobName})
	fake.recordInvocation("SaveIdealInputVersions", []interface{}{inputVersions, jobName})
	fake.saveIdealInputVersionsMutex.Unlock()
	if fake.SaveIdealInputVersionsStub != nil {
		return fake.SaveIdealInputVersionsStub(inputVersions, jobName)
	} else {
		return fake.saveIdealInputVersionsReturns.result1
	}
}

func (fake *FakeSchedulerDB) SaveIdealInputVersionsCallCount() int {
	fake.saveIdealInputVersionsMutex.RLock()
	defer fake.saveIdealInputVersionsMutex.RUnlock()
	return len(fake.saveIdealInputVersionsArgsForCall)
}

func (fake *FakeSchedulerDB) SaveIdealInputVersionsArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveIdealInputVersionsMutex.RLock()
	defer fake.saveIdealInputVersionsMutex.RUnlock()
	return fake.saveIdealInputVersionsArgsForCall[i].inputVersions, fake.saveIdealInputVersionsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) SaveIdealInputVersionsReturns(result1 error) {
	fake.SaveIdealInputVersionsStub = nil
	fake.saveIdealInputVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) SaveCompromiseInputVersions(inputVersions algorithm.InputMapping, jobName string) error {
	fake.saveCompromiseInputVersionsMutex.Lock()
	fake.saveCompromiseInputVersionsArgsForCall = append(fake.saveCompromiseInputVersionsArgsForCall, struct {
		inputVersions algorithm.InputMapping
		jobName       string
	}{inputVersions, jobName})
	fake.recordInvocation("SaveCompromiseInputVersions", []interface{}{inputVersions, jobName})
	fake.saveCompromiseInputVersionsMutex.Unlock()
	if fake.SaveCompromiseInputVersionsStub != nil {
		return fake.SaveCompromiseInputVersionsStub(inputVersions, jobName)
	} else {
		return fake.saveCompromiseInputVersionsReturns.result1
	}
}

func (fake *FakeSchedulerDB) SaveCompromiseInputVersionsCallCount() int {
	fake.saveCompromiseInputVersionsMutex.RLock()
	defer fake.saveCompromiseInputVersionsMutex.RUnlock()
	return len(fake.saveCompromiseInputVersionsArgsForCall)
}

func (fake *FakeSchedulerDB) SaveCompromiseInputVersionsArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveCompromiseInputVersionsMutex.RLock()
	defer fake.saveCompromiseInputVersionsMutex.RUnlock()
	return fake.saveCompromiseInputVersionsArgsForCall[i].inputVersions, fake.saveCompromiseInputVersionsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) SaveCompromiseInputVersionsReturns(result1 error) {
	fake.SaveCompromiseInputVersionsStub = nil
	fake.saveCompromiseInputVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) DeleteCompromiseInputVersions(jobName string) error {
	fake.deleteCompromiseInputVersionsMutex.Lock()
	fake.deleteCompromiseInputVersionsArgsForCall = append(fake.deleteCompromiseInputVersionsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("DeleteCompromiseInputVersions", []interface{}{jobName})
	fake.deleteCompromiseInputVersionsMutex.Unlock()
	if fake.DeleteCompromiseInputVersionsStub != nil {
		return fake.DeleteCompromiseInputVersionsStub(jobName)
	} else {
		return fake.deleteCompromiseInputVersionsReturns.result1
	}
}

func (fake *FakeSchedulerDB) DeleteCompromiseInputVersionsCallCount() int {
	fake.deleteCompromiseInputVersionsMutex.RLock()
	defer fake.deleteCompromiseInputVersionsMutex.RUnlock()
	return len(fake.deleteCompromiseInputVersionsArgsForCall)
}

func (fake *FakeSchedulerDB) DeleteCompromiseInputVersionsArgsForCall(i int) string {
	fake.deleteCompromiseInputVersionsMutex.RLock()
	defer fake.deleteCompromiseInputVersionsMutex.RUnlock()
	return fake.deleteCompromiseInputVersionsArgsForCall[i].jobName
}

func (fake *FakeSchedulerDB) DeleteCompromiseInputVersionsReturns(result1 error) {
	fake.DeleteCompromiseInputVersionsStub = nil
	fake.deleteCompromiseInputVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchedulerDB) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	} else {
		return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
	}
}

func (fake *FakeSchedulerDB) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakeSchedulerDB) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakeSchedulerDB) LeaseScheduling(arg1 lager.Logger, arg2 time.Duration) (db.Lease, bool, error) {
	fake.leaseSchedulingMutex.Lock()
	fake.leaseSchedulingArgsForCall = append(fake.leaseSchedulingArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("LeaseScheduling", []interface{}{arg1, arg2})
	fake.leaseSchedulingMutex.Unlock()
	if fake.LeaseSchedulingStub != nil {
		return fake.LeaseSchedulingStub(arg1, arg2)
	} else {
		return fake.leaseSchedulingReturns.result1, fake.leaseSchedulingReturns.result2, fake.leaseSchedulingReturns.result3
	}
}

func (fake *FakeSchedulerDB) LeaseSchedulingCallCount() int {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return len(fake.leaseSchedulingArgsForCall)
}

func (fake *FakeSchedulerDB) LeaseSchedulingArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	return fake.leaseSchedulingArgsForCall[i].arg1, fake.leaseSchedulingArgsForCall[i].arg2
}

func (fake *FakeSchedulerDB) LeaseSchedulingReturns(result1 db.Lease, result2 bool, result3 error) {
	fake.LeaseSchedulingStub = nil
	fake.leaseSchedulingReturns = struct {
		result1 db.Lease
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSchedulerDB) GetPipelineName() string {
	fake.getPipelineNameMutex.Lock()
	fake.getPipelineNameArgsForCall = append(fake.getPipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineName", []interface{}{})
	fake.getPipelineNameMutex.Unlock()
	if fake.GetPipelineNameStub != nil {
		return fake.GetPipelineNameStub()
	} else {
		return fake.getPipelineNameReturns.result1
	}
}

func (fake *FakeSchedulerDB) GetPipelineNameCallCount() int {
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return len(fake.getPipelineNameArgsForCall)
}

func (fake *FakeSchedulerDB) GetPipelineNameReturns(result1 string) {
	fake.GetPipelineNameStub = nil
	fake.getPipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSchedulerDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.getNextPendingBuildMutex.RLock()
	defer fake.getNextPendingBuildMutex.RUnlock()
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.getCompromiseBuildInputsMutex.RLock()
	defer fake.getCompromiseBuildInputsMutex.RUnlock()
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	fake.useInputsForBuildMutex.RLock()
	defer fake.useInputsForBuildMutex.RUnlock()
	fake.leaseResourceCheckingForJobMutex.RLock()
	defer fake.leaseResourceCheckingForJobMutex.RUnlock()
	fake.leaseResourceCheckingForJobAcquiredMutex.RLock()
	defer fake.leaseResourceCheckingForJobAcquiredMutex.RUnlock()
	fake.getAlgorithmInputConfigsMutex.RLock()
	defer fake.getAlgorithmInputConfigsMutex.RUnlock()
	fake.saveIdealInputVersionsMutex.RLock()
	defer fake.saveIdealInputVersionsMutex.RUnlock()
	fake.saveCompromiseInputVersionsMutex.RLock()
	defer fake.saveCompromiseInputVersionsMutex.RUnlock()
	fake.deleteCompromiseInputVersionsMutex.RLock()
	defer fake.deleteCompromiseInputVersionsMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.leaseSchedulingMutex.RLock()
	defer fake.leaseSchedulingMutex.RUnlock()
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSchedulerDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ scheduler.SchedulerDB = new(FakeSchedulerDB)
